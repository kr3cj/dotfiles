alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias ducks="sudo du -cshx ./ | sort -h"
alias cdd="homeshick cd dotfiles"
alias pp="source ~/.bash_profile"

function pathadd() {
  unset newpath
  local newpath=${1%/}
  if [[ ! -d "${newpath}" ]] ; then
    # echo "Directory \"${1}\" does not exist."
    return
  fi
  if [[ "${PATH}" =~ (^|:)"${newpath}"(:|$) ]] ; then
    # echo "Path \"${newpath}\" already exists in path \"${PATH}\"."
    return
  fi
  if [[ "${2}" == "after" ]] ; then
    export PATH="${PATH}:${newpath}"
  else
    export PATH="${newpath}:${PATH}"
  fi
}

function gitp {
  local gbranch=${1:-master}
  git fetch --prune --all
  git checkout ${gbranch}
  git pull origin ${gbranch}
  # git fetch origin --prune
  # git fetch --tags
  git status
}

function _create_socks_proxy {
  local host1=${1}
  local port1=${2}
  local username=${3}
  local test_url=${4:-"http://www.google.com"}
  local ssh_proxy_options="-f -N -D"

  # note: lsof still returns a row when port open but dead: lsof -nP -i4TCP:${port1} | grep -q LISTEN
  # --socks5-hostname
  if [[ $(curl \
    --connect-timeout 1 \
    --silent \
    --output /dev/null \
    --write-out "%{http_code}" \
    --head \
    --socks5 localhost:${port1} \
    ${test_url} \
    ) -ne 200 \
  ]] ; then
    # first kill any old sessions
    pgrep -f "ssh .* ${ssh_proxy_options} ${port1} ${username}@${host1}"
    pkill -f "ssh .* ${ssh_proxy_options} ${port1} ${username}@${host1}"

    echo "Establishing ssh tunnel with ${username}@${host1}:${port1}..."
    [[ ${host1} == "home.${CUSTOM_HOME_DOMAIN}" ]] && \
      lpass show --password --clip "proxy.${CUSTOM_NAS_HOST#*\.}"
    # TODO: capture output only if the command fails
    ssh ${ssh_proxy_options} ${port1} "${username}@${host1}" \
      -o TCPKeepAlive=yes -o ConnectTimeout=1 -o ConnectionAttempts=1 2> /dev/null
    pbcopy </dev/null
  fi
  [[ ${?} -ne 0 ]] && echo "Unable to establish ssh connection to ${host1}."
}

function port {
  timeout 2 bash -c "echo >/dev/tcp/${1}/{2}" > /dev/null 2>&1 && echo success || echo failure
}

function acp {
  cp -av ${1} ${1}.$(date +%Y-%m-%d %H-%M)
  # cp -av ${1} ${1}.$(date --rfc-3339=seconds)
}

function find-error() {
  sudo grep -riE 'DENIED|ERR|EXIST|FAIL|INVALID|SPECIFIED|SUCH|UNABLE|WARN' ${1}
}

function speedtest {
  curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py \
  | python -
}

if [[ "${IS_OSX}" == "true" ]]; then
  alias ls="ls -G"
  alias ll="ls -hl -G"
  alias srm="/bin/rm -vP"
  alias slack="open -a Slack"
  alias spotify="open -a Spotify"
  # alias gphoto="open --background -a \"Google Photos Backup\""
  alias gphoto="open --background -a \"Backup and Sync\""
  alias vc="/opt/cisco/anyconnect/bin/vpn connect ${CUSTOM_WORK_DOMAINS[2]/\.*/}"
  alias vd="/opt/cisco/anyconnect/bin/vpn disconnect"
  alias vs="/opt/cisco/anyconnect/bin/vpn status"

  function lpw {
    lpass show --password --clip LDAP
    # schedule clearing of the clipboard after 5 seconds
    echo "$(brew --prefix)/opt/coreutils/libexec/gnubin/sleep 5 ; /usr/bin/pbcopy </dev/null" | at now
  }

  function ssh {
    local host1="${@}"
    if [[ "${host1}" =~ (wyn*|for*|lax*|fsh*|lsh*|finf*|linf*|192.168.*|\
macmini*|wheezybuild*|squeezebuild*|builder\
\.$(echo ${CUSTOM_WORK_DOMAINS[@]} | tr ' ' '|')) ]]; then
      # copy ldap password to clipboard before ssh'ing to work hosts
      lpass show --password --clip LDAP && $(which ssh) ${host1}
      pbcopy </dev/null
    elif [[ "${host1}" == "home.${CUSTOM_HOME_DOMAIN}" ]]; then
      lpass show --password --clip "proxy.${CUSTOM_NAS_HOST#*\.}" && \
        $(which ssh) ${host1}
      pbcopy </dev/null
    elif [[ "${host1}" =~ (macbuild*) ]]; then
      lpass show --password --clip "AD" && \
        $(which ssh) ${host1}
      pbcopy </dev/null
    else
      $(which ssh) ${host1}
    fi
  }
elif [[ "${IS_LINUX}" == "true" ]]; then
  alias ls="ls --color=auto"
  alias ll="ls -hl --color=auto"
  alias list-services="systemctl list-unit-files --type=service | grep enabled | \
    cut -d. -f1 | sort"
  # enforce one use of clipboard memory
  export LPASS_CLIPBOARD_COMMAND="xclip -selection clipboard -in -l 1"
fi
