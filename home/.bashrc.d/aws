[[ $- = *i* ]] || return
# http://docs.aws.amazon.com/cli/latest/userguide/cli-install-macos.html

export AWS_SESSION_TTL=12h
export AWS_FEDERATION_TOKEN_TTL=12h
export AWS_ASSUME_ROLE_TTL=1h

# This allows for running aws-cli commands securely
## Usage: `awv stage-admin aws s3 ls`
function awv()
{
  local profile=${1}
  shift
  aws-vault exec ${profile} -- ${*}
}

function aws-vault {
  lpass show --password --clip "${CUSTOM_WORK_DOMAINS[0]/.com/} macbook" || echo "Unable to cache pw."
  $(which aws-vault) ${*}
}
# This allows for logging into the AWS console as a federated user via your IAM keys instead of the console password.
## Usage: `awslogin staging`
function awslogin()
{
  aws-vault login ${*}
}

# This creates a new shell session with the correct environment variables set so you can run SDK programs without issue.
# Note `-il` will run all your normal Login and BashRC files. (interactive, login flags)
## Usage: `awsshell staging`
function awsshell()
{
  aws-vault exec ${1} -- ${SHELL} -il
}

alias ec2="aws-vault login default"

# aws creds
# aws-vault exec default --env | grep AWS

# if [[ -f ~/.aws_auth ]] ; then
#   source ~/.aws_auth
#   export AWS_CREDENTIAL_FILE=~/.aws_auth
#   # export AWS_IAM_HOME=~/bin/amazon/iam
#   # pathadd ${AWS_IAM_HOME}/bin
#
#   # use env variables over cli profiles for friendlier k8s integration
#   function set-aws()
#   {
#     # TODO: convert to vault provisioning
#     local acct=${1}
#     case ${acct} in
#       ${CUSTOM_WORK_DOMAINS[0]/\.*/})
#         echo "Setting AWS credentials to ${CUSTOM_WORK_DOMAINS[0]/\.*/}"
#         export AWS_ACCESS_KEY=${} AWS_SECRET_ACCESS_KEY=${} ;;
#       *ops*)
#         echo "Setting AWS credentials to ${CUSTOM_WORK_DOMAINS[0]/\.*/}-ops"
#         export AWS_ACCESS_KEY=${} AWS_SECRET_ACCESS_KEY=${} ;;
#       *)
#         echo "Unable to set AWS credentials; Unknown account"
#         unset AWS_ACCESS_KEY AWS_SECRET_ACCESS_KEY ;;
#     esac
#   }
# fi

function get-ec2-id-from-pod ()
{
  # only requires kube config with correct context and namespace set
  kubectl get no $(kubectl get po/${@} -ojsonpath='{.spec.nodeName}') \
    -ojsonpath='{.spec.externalID}' ; echo

  # alternative requires exec'ing into container and the curl binary
  # kubectl exec -it ${@} -- curl http://169.254.169.254/latest/meta-data/instance-id ; echo
}
function get-ec2-hostname-from-pod ()
{
  # only requires kube config with correct context set
  kubectl get po/${@} -ojsonpath='{.spec.nodeName}' ; echo # '{.status.hostIP}'

  # alternative requires exec'ing into container and the curl binary
  # kubectl exec -it ${@} -- curl http://169.254.169.254/latest/meta-data/hostname ; echo
}
function get-ec2-id-from-hostname ()
{
  # takes in one parameter: ec2 hostname
  # for k8s-a which is in us-east-2, hostnames include the region, so filter those
  # only requires kube config with correct context set
  kubectl get no/${@/us-east-2.compute/ec2} -ojsonpath="{.spec.externalID}" \
    ; echo

  # alternative requires ssh access
  # ssh ${@/us-east-2.compute/ec2} "curl --silent http://169.254.169.254/latest/meta-data/instance-id" ; echo
}
function get-ec2-hostname-from-id ()
{
  # takes in one parameter: ec2 instance id
  # only requires kube config with correct context set
  kubectl get no -o=jsonpath="{.items[?(@.spec.externalID==\"${@}\")].metadata.name}" \
    ; echo

  # alternative requires aws-vault, MFA token, and aws-cli
  # takes in two paramters: aws-vault-instance-name-env (prod|staging|a) instance-id
  # aws-vault exec k8s-${1}-kops -- \
  #   aws ec2 describe-instances \
  #     --instance-ids ${2} \
  #     --query Reservations[].Instances[].PrivateDnsName \
  #     --output text
}