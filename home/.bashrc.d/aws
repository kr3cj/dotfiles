[[ $- = *i* ]] || return
${IS_MACOS} || return
# http://docs.aws.amazon.com/cli/latest/userguide/cli-install-macos.html

export AWS_SESSION_TTL=12h
export AWS_FEDERATION_TOKEN_TTL=12h
export AWS_ASSUME_ROLE_TTL=1h # 4h for devtoolsSandboxAccountAccessRole
export AWS_DEFAULT_REGION=us-east-1

# move saml2aws variables to config file
export SAML2AWS_CONFIGFILE=~/.saml2aws
export SAML2AWS_SESSION_DURATION=43200 # 12 hour max for "saml2aws login"
# export SAML2AWS_MFA="TOTP"
# export SAML2AWS_ROLE=${CUSTOM_WORK_IAM_ROLE}
# export SAML2AWS_PROFILE=


function saml() {
  # saml2aws logins can have a max session duration of 12h, but role chaining can only have a max session duration of 1h
  local args
  # [[ ${@} =~ "--session-duration" ]] || args="--session-duration=${SAML2AWS_SESSION_DURATION}"
  # [[ ${@} =~ "--role" ]] || args="${args} --role=${CUSTOM_WORK_IAM_ROLE}"
  # [[ ${@} =~ "--mfa" ]] || args="${args} --mfa=${SAML2AWS_MFA}"
  [[ ${@} =~ "--config" ]] || args="${args} --config=${SAML2AWS_CONFIGFILE}"
  # [[ ${@} =~ "--skip-prompt" ]] || args="${args} --skip-prompt"
  if [[ ${@} =~ "--exec-profile" ]] ; then
    export MY_AWS_PROFILE=$(echo ${@} | sed -r 's/.*--exec-profile[=,\ ]([^ ]+).*/\1/')
    # add 1 hour session duration if missing
    [[ ${@} =~ "--session-duration" ]] || args="${args} --session-duration=3600"
  fi
  [[ ${VERBOSE} -ge 1 ]] && \
    echo "Running \"$(which saml2aws) ${args} ${*}\""
  saml2aws ${args} ${*}
}

function get-ec2-id-from-pod() {
  # only requires kube config with correct context and namespace set
  basename "$(kubectl --kubeconfig ~/.kube/${1} \
   get no/$(kubectl --kubeconfig ~/.kube/${1} get po/${2} -ojsonpath='{.spec.nodeName}') \
    -ojsonpath='{.spec.providerID}')"
    # -ojsonpath='{.metadata.labels.alpha\.eksctl\.io/instance-id}' ; echo

  # alternative requires exec'ing into container and the curl binary
  # kubectl exec -it ${@} -- curl http://169.254.169.254/latest/meta-data/instance-id ; echo
}
function get-ec2-hostname-from-pod() {
  # only requires kube config with correct context set
  kubectl --kubeconfig ~/.kube/${1} get po/${2} -ojsonpath='{.spec.nodeName}' \
  ; echo # '{.status.hostIP}'

  # fall back requires exec'ing into container and the curl binary
  # kubectl exec -it ${@} -- curl http://169.254.169.254/latest/meta-data/hostname ; echo
}
function get-ec2-id-from-hostname() {
  # takes in one parameter: ec2 hostname
  # figures out cluster from hostname via private utility function
  basename "$(kubectl --kubeconfig ~/.kube/$(map-host-to-cluster ${1}) get no/${1} \
    -ojsonpath='{.spec.providerID}')"
    # -ojsonpath="{.metadata.labels.alpha\.eksctl\.io/instance-id}" \
    # echo

  # if [[ -n ${result} ]]; then
  #   echo ${result}
  # else
  #   # echo "Falling back for non-k8s nodes (requires ssh access)""
  #   ssh ${@/us-east-2.compute/ec2} "curl --silent http://169.254.169.254/latest/meta-data/instance-id" ; echo
  # fi
}
function get-ec2-hostname-from-id() {
  # takes in two parameters: kube config name (assumes one cluster per config) and ec2 instance id
  kubectl --kubeconfig ~/.kube/${1} get no \
    -o=jsonpath="{.items[?(@.metadata.labels.alpha\.eksctl\.io/instance-id=='${2}')].metadata.name}" \
    ; echo

  # if [[ -n ${result} ]]; then
     # echo ${result}
  # else
  #   echo "Falling back for non-k8s nodes (requires saml2aws, aws-cli)"
  #   # takes in two paramters: instance-id and saml2aws profile
  #   saml2aws exec --exec-profile=${2} -- \
  #     aws ec2 describe-instances \
  #     --instance-ids ${1} \
  #     --query Reservations[].Instances[].PrivateDnsName \
  #     --output text
  # fi
}

function get-latest-eks-ami-release-version() {
  local current_kube_version="$(kubectl version --client=false -ojson | \
    jq -r '.serverVersion.major + "." + .serverVersion.minor' | sed 's/+$//g')"
  local desired_kube_version="${1:-$current_kube_version}"

  aws ec2 --profile="${CUSTOM_WORK_IAM_PROFILE_PREFIX}-k8s-stage" describe-images --owners amazon \
   --image-ids "$(aws ssm --profile=${CUSTOM_WORK_IAM_PROFILE_PREFIX}-k8s-stage get-parameters \
    --names /aws/service/eks/optimized-ami/${desired_kube_version%+}/amazon-linux-2/recommended/image_id \
    --region us-east-1 | jq -r '.Parameters[0].Value')" | jq -r '.Images[0].Name'
}

function get-all-eks-ami-release-versions-and-ids() {
  local the_profile="${IBEX_PROFILE:-${CUSTOM_WORK_IAM_PROFILE_PREFIX}-k8s-stage}"
  if [[ -z ${IBEX_PROFILE} ]]; then
    echo -e "\${IBEX_PROFILE} not set so I defaulted profile to \"${the_profile}\"; ymmv\n"
  fi

  local current_kube_version="$(kubectl version --client=false -ojson | \
      jq -r '.serverVersion.major + "." + .serverVersion.minor' | sed 's/+$//g')"
  local desired_kube_version="${1:-$current_kube_version}"
  if [[ -z ${1} ]]; then
    echo -e "K8s api major and minor version not passed in (ex: 1.19), grabbed from KUBECONFIG (\"${current_kube_version}\").\n"
  fi

  echo "Grabbing eks-ami releaseVersions and AMI IDs for k8s version ${desired_kube_version}... (could take up to 30s)"
  echo " (see also https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html)"
  echo

  {
    echo "ManagedNodeGroups UnmanagedNodeGroups"
    echo "----------------- ---------------------"
    for param1 in $(aws ssm --profile=${the_profile} describe-parameters --region us-east-1 --max-items 100 \
                    --parameter-filters "Key=Path,Values=/aws/service/eks/optimized-ami/${desired_kube_version%+}/amazon-linux-2/" \
                    | jq -r '.Parameters[].Name' | grep -v recommended | sort -r); do
      aws ssm --profile=${the_profile} get-parameters --names ${param1} --region us-east-1 | \
        jq -r '.Parameters[0].Value' | jq -r '.release_version + " " + .image_id'
    done
  } | column -t
}

function show-domain-registration-expirations() {
  for profile1 in $(grep \ ${CUSTOM_WORK_IAM_PROFILE_PREFIX}- ~/.aws/config \
   | awk '{print $2}' | sed 's/]^//g'); do
    echo ${profile1%]}
    aws --profile ${profile1%]} route53domains list-domains | \
     jq -r '.Domains | map(.DomainName + " " + .Expiry)[]' - | sort ; \
  done | column -t
}

function show-acm-cert-expirations() {
  for profile1 in $(grep \ ${CUSTOM_WORK_IAM_PROFILE_PREFIX}- ~/.aws/config \
   | awk '{print $2}' | sed 's/]^//g'); do
    echo ${profile1%]}
    for arn1 in $(aws --profile ${profile1%]} acm list-certificates --max-items 100 \
     | jq -r '.CertificateSummaryList[].CertificateArn'); do
      aws --profile ${profile1%]} acm describe-certificate --certificate-arn ${arn1} \
       | jq -r '.Certificate.DomainName + "\t" + .Certificate.NotAfter' -; \
       done | sort | column -t
    echo
  done
}
