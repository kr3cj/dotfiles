[[ $- = *i* ]] || return
${IS_MACOS} || return

# export KUBECONFIG=~/.kube/k3sa
 export KUBECONFIG=$(find ~/.kube/ \
   -mindepth 1 \
   -maxdepth 1 \
   -type l \
   ! -name minikube \
   | sort \
   | tr '\n' ':')
  # -printf "%p:" \

# source <(kubectl completion bash) # slow
# alias k=kubectl
# source <(kubectl completion bash | sed 's/kubectl/k/g' )

source ~/.private-utils.sh

function k() {
  local cluster=${1}
  if ! [[ -r ~/.kube/${cluster} ]]; then
    echo "No kubeconfig found for \"${cluster}\"!"
    return 1
  fi
  shift
  local action="${@}"

  local my_aws_profile="$(map-cluster-to-profile ${cluster})"
  # verify that eks clusters mapped to a my_aws_profile
  if [[ ! ${cluster} =~ k8s ]] && [[ "${my_aws_profile}" == "" ]]; then
    return 1
  fi
  # if ! $(on_vpn); then
  #   work_vpn
  #   echo
  # fi

  local kube_config="--kubeconfig ${HOME}/.kube/${cluster}"
  # some kubectl plugin commands won't work with "--kubeconfig"
  if [[ ${action} =~ "outdated" ]] || [[ ${action} =~ "node-admin" ]]; then
    kube_config=""
  fi
  # automatic sorting and displaying of labels for common get commands
  case ${action} in
    *get?events*)
      action="${action} --sort-by=.lastTimestamp" ;;
    *get?po*)
      action="${action} --sort-by=.metadata.creationTimestamp" ;;
    *get?no*)
      if [[ ${cluster} =~ k8s ]]; then
        action="${action} --label-columns=kubernetes.io/role,function --sort-by=.metadata.creationTimestamp"
      else
        action="${action} --label-columns=nodegroup_name,function --sort-by=.metadata.creationTimestamp"
      fi ;;
    *)
      [[ ${VERBOSE} -ge 1 ]] && echo "matched global"
      action="${action}" ;;
  esac

  [[ ${VERBOSE} -ge 1 ]] && \
    echo "Running: \"$(which kubectl) ${kube_config} ${action}\""
  kubectl ${kube_config} ${action} #--context admin@${cluster}
}

function ibexs() {
  if ! [[ $(pwd) =~ ibex ]] ; then
    echo "You must be in the ibex repo to run it"
    exit 1
  fi

  local cluster=${1}
  if ! [[ -r ~/.kube/${cluster} ]]; then
    echo "No kubeconfig found for \"${cluster}\"!"
    return 1
  fi
  shift
  local args="${@}"

  local my_cluster_path="$(map-cluster-to-path ${cluster})"

  [[ ${VERBOSE} -ge 1 ]] && \
    echo "Running: ./ibex --cluster ${my_cluster_path} ${args}"
  ./ibex --cluster ${my_cluster_path} ${args}
}

function h() {
  local cluster=${1}
  if ! [[ -r ~/.kube/${cluster} ]]; then
    echo "No kubeconfig found for \"${cluster}\"!"
    return 1
  fi
  shift
  local action=${@} # ex: "get pod"

  local my_aws_profile="$(map-cluster-to-profile ${cluster})" # dynamically determine

  # verify that eks clusters mapped to an my_aws_profile
  if [[ ! ${cluster} =~ k8s ]] && [[ "${my_aws_profile}" == "" ]]; then
    echo "Could not map the cluster name to an aws profile."
    return 1
  fi
  # if ! $(on_vpn); then
  #   work_vpn
  #   echo
  # fi

  local kube_config="--kubeconfig ${HOME}/.kube/${cluster}"

  # old kops clusters dont need saml2aws wrapper
  # local wrapper="saml2aws exec --exec-profile=${my_aws_profile} --"
  local helm_path="/Users/${LOGNAME}/.asdf/shims/helm"
  if [[ ${cluster} =~ k8s ]]; then
    wrapper=""
    # kops clusters (k8s and k8s-staging) running helm 2.14.2
    asdf install helm 2.14.2
    helm_path="$(asdf where helm 2.14.2)/bin/helm"
  fi

  [[ ${VERBOSE} -ge 1 ]] && \
    echo "Running: \"${helm_path} ${kube_config} ${action}\""
  ${helm_path} ${kube_config} ${action} #--kube-context admin@${cluster}
}

# kubectl plugin manager: krew
export KREW_ROOT=${HOME}/.krew
pathadd ${KREW_ROOT}/bin

function _get_latest_version_from_github()
{
  # mostly replaced by kubectl/krew outdated
  local path=${@}
  if ! [[ ${path} =~ [a-z]\/[a-z] ]]; then
    echo "Invalid path provided to ${FUNCNAME[0]}. Must be like \"this/that\""
    return 1
  fi
  local version=$(curl -s -H "Authorization: Bearer ${GITHUB_API_TOKEN}" \
    https://api.github.com/repos/${path}/releases/latest | jq -r '.tag_name')
  if [[ ${version} =~ ^v[0-9].* ]] || [[ ${version} =~ ^[0-9].* ]]; then
    echo ${version/v}
  else
    echo "Invalid version returned for \"${FUNCNAME[0]} ${path}\""
    return 1
  fi
}
function get_kube_versions()
{
  # mostly replaced by kubectl/krew outdated
  local L8ST_COREOS_V=$(curl -s https://coreos.com/dist/aws/aws-stable.json \
    | jq -r '.release_info.version') \
  local CURR_KOPS_V=$(kops version | awk '{print $2}') \
  local L8ST_KOPS_V=$(_get_latest_version_from_github "kubernetes/kops")
  local CURR_K8S_V=$(kubectl version --short --output=json | jq -r '.serverVersion.gitVersion')
  local L8ST_K8S_V=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)
  local CURR_HELMC_V=$(helm version --client --short | awk '{print $2}')
  local CURR_HELMS_V=$(helm version --server --short | awk '{print $2}')
  local L8ST_HELM_V=$(_get_latest_version_from_github "helm/helm")
  # TODO: GO_V=$(kubectl version --short --output=json | jq -r '.serverVersion.goVersion')
  # TODO: Versions of kernel, Debian/coreos/container-optimized-os-from-google, etcd, kube-aws,
  #  kiam-server, kernel, nginx ingress, dashboard, heapster->metrics-server, kube-state-metrics, prometheus, eksctl?
  # TODO: providers for dns and network layer
  # datadog agent+chart, sumologic-fluentd agent+chart, runatlantis/atlantis
  # update di-4325

  ### Tools that come with the cluster (indirect versioning correlation)
  # docker: https://github.com/docker/docker-ce/releases/latest
  # cluster-autoscaler latest version matches k8s: https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler#releases
  # kube-state-metrics: https://github.com/kubernetes/kube-state-metrics#compatibility-matrix

  # TODO: utilize column command?
  cat << TABLE_EOF
  +------------+------------------+----------------+
  | COMPONENT  | CURRENT VERSION  | LATEST VERSION |
  +------------+------------------+----------------+
  | CoreOS     | N/A              | ${L8ST_COREOS_V}       |
  +------------+------------------+----------------+
  | Kops       | ${CURR_KOPS_V}           | ${L8ST_KOPS_V}         |
  +------------+------------------+----------------+
  | Kubernetes | ${CURR_K8S_V}          | ${L8ST_K8S_V}        |
  +------------+------------------+----------------+
  | Helm Client| ${CURR_HELMC_V} | ${L8ST_HELM_V}        |
  +------------+------------------+----------------+
  | Helm Server| ${CURR_HELMS_V} | ${L8ST_HELM_V}        |
  +------------+------------------+----------------+
TABLE_EOF
}

# function doit () {
#   local saml2aws-profile=${1}
#   shift
#   local nodes=${@}
#   for node1 in ${nodes} ; do
#     echo -e "\n starting on ${node1} at $(date)"
#     kubectl drain ${node1} --ignore-daemonsets --force --delete-local-data
#     saml2aws exec --exec-profile=${saml2aws-profile} -- \
#       aws ec2 terminate-instances --instance-ids \
#         kubectl get nodes -o go-template --template=\'{{.spec.externalID}}\' ${nodeid}
#   done
# }

# kubectl get node \
  # -l kubernetes.io/role=node,failure-domain.beta.kubernetes.io/zone=us-east-${az} \
  # --label-columns function
  # --no-headers \
  # --sort-by metadata.creationTimestamp

  # -o name

# I can get a list of pods sorted by the node its on using the below.
# But how can I show *node* labels by pod?
# kubectl get pods -o wide --sort-by="{.spec.nodeName}"

# get list of running pods on the node
# kubectl get po --field-selector=spec.nodeName=<ec2_hostname> | grep -v event-observer

# get events by specific pod/node
# kubectl get events -n operations --sort-by='{.lastTimestamp}' --field-selector involvedObject.kind=Pod,involvedObject.name=datadog-worker-bv9nk

# force pod deletion (only removes from etcd, doesn't force kill container on node)
# kubectl -n operations delete pod/host-agent-datadog-l22qs --grace-period=0 --force

# show count of deployment revisionHistoryLimit by microservice (replicationsets)
# kubectl get deploy -ogo-template='{{range .items}}{{.metadata.name}}{{"\t"}}{{.spec.revisionHistoryLimit}}{{"\n"}}{{end}}' | column -t | awk '{print $2}' | sort | uniq -c

# show count of configmaps by microservice
# kubectl get rs -lapp -ogo-template='{{range .items}}{{.metadata.labels.app}}{{"\n"}}{{end}}' | awk '{print $1}' | sort | uniq -c

# show counts of unique images/versions by namespace (watch is helpful for rollouts)
# watch "kubectl -n operations get po --sort-by=.metadata.creationTimestamp -o jsonpath='{..image}' | tr -s '[[:space:]]' '\n' | sort | uniq -c"

# show counts of unique images/version for kubelet
# kubectl --kubeconfig get no --sort-by=.metadata.creationTimestamp -o jsonpath='{..kubeletVersion}' | tr -s '[[:space:]]' '\n' | sort | uniq -c