[[ $- = *i* ]] || return
${IS_OSX} || return

export KUBECONFIG=~/.kube/config

source <(kubectl completion bash)
alias k=kubectl
source <(kubectl completion bash | sed 's/kubectl/k/g' )

# k8s auth
[[ -f ~/.k8s_auth ]] && source ~/.k8s_auth
alias kwatch="watch kubectl get no,ds,deploy,po,svc,ing,cm,pvc,secret,pdb,rs,hpa"

# The below functions are useful for calling one time kops commands on any env, regardless of current kubectx pointers
function kops-cmd () {
  # TODO: integrate asdf kops versions, e.g. "asdf install kops ${version}"
  # this is useful for running one kops command without any prior configs for the cluster
  if [[ ${#} -lt 2 ]]; then
    echo "Invalid arguments. You must supply a cluster letter and a kops command: \"kops-cmd a get clusters\""
    return 1
  fi
  local cluster_letter="${1}"
  shift
  local kops_cmd="${@}"
  if [[ "${cluster_letter}" != [a-z] ]]; then
    echo "Not a valid cluster name. Quitting."
    return 1
  fi
  if ! $(aws-vault list | grep ^k8s-${cluster_letter}\  > /dev/null); then
    echo "Setting up an aws profile for \"k8s-${cluster_letter}\" in ~/.aws/config ..."
    local default_aws_acct target_aws_acct aws_region username
    read -p "Please enter the target aws account number: " target_aws_acct
    read -p "Please enter the region (default: us-east-1): " aws_region
    aws_region=${aws_region:-us-east-1}
    username=$(git config --global user.email)
    cat << EOF >> ~/.aws/config

[profile k8s-${cluster_letter}]
role_arn=arn:aws:iam::${target_aws_acct}:role/k8s-${cluster_letter}.${CUSTOM_WORK_DOMAINS[1]}-AdminRole
source_profile = default
region = ${aws_region}
mfa_serial = arn:aws:iam::${CUSTOM_WORK_DEFAULT_AWS_ACCT}:mfa/${username/@${CUSTOM_WORK_DOMAINS[0]}/}
EOF
  # aws-vault remove k8s-${cluster_name} # doesn't work
  fi

  local kops_options="--name k8s-${cluster_letter}.${CUSTOM_WORK_DOMAINS[1]} \
    --state=s3://${CUSTOM_WORK_DOMAINS[0]/.com/}-kops-store-k8s-${cluster_letter}.${CUSTOM_WORK_DOMAINS[1]}"

  if ! $(kubectx | grep ^k8s-${cluster_letter}.${CUSTOM_WORK_DOMAINS[1]}$ > /dev/null); then
    echo "Creating kubectl context for cluster \"k8s-${cluster_letter}\"..."
    aws-vault exec k8s-${cluster_letter} -- kops ${kops_options} export kubecfg
    # deleting from kubeconfig
    # kubectx -d k8s-${cluster_letter}.${CUSTOM_WORK_DOMAINS[1]}
    #   OR kubectl config delete-context k8s-${cluster_letter}.${CUSTOM_WORK_DOMAINS[1]}
    # kubectl config delete-cluster k8s-${cluster_letter}.${CUSTOM_WORK_DOMAINS[1]}
    # kubectl config set-context "" # https://github.com/kubernetes/kubectl/issues/483
  fi

  # set namespace to default, if necessary
  # if "default" != $(kubectl config view -o=jsonpath="{.contexts[?(@.name==\"$(kubectl config current-context)\")].context.namespace}"); then
  #   kubectl config set-context $(kubectl config current-context) --namespace=default
  # fi
  lpass show --password --clip "${CUSTOM_WORK_DOMAINS[0]/.com/} macbook"
  aws-vault exec k8s-${cluster_letter} -- kops \
    ${kops_options} \
    ${kops_cmd}
}
# TODO: collapse these into above function
# TODO: find out why calling the functions directly doesnt work (must paste output)
function kops-cmd-prod() {
  lpass show --password --clip "${CUSTOM_WORK_DOMAINS[0]/.com/} macbook"
  aws-vault exec k8s-prod-kops -- kops \
    --name k8s.${CUSTOM_WORK_DOMAINS[1]} \
    --state=s3://kops-store.${CUSTOM_WORK_DOMAINS[1]} \
    ${@}
  # aws-vault exec kops-admin -- ${SHELL} -il --init-file <(echo "\
  #   kops export kubecfg --name k8s.${CUSTOM_WORK_DOMAINS[1]} --state=s3://kops-store.${CUSTOM_WORK_DOMAINS[1]}\
  # ")
}
function kops-cmd-staging() {
  lpass show --password --clip "${CUSTOM_WORK_DOMAINS[0]/.com/} macbook"
  aws-vault exec k8s-staging-kops -- kops \
    --name k8s-staging.${CUSTOM_WORK_DOMAINS[1]} \
    --state=s3://kops-store-staging.${CUSTOM_WORK_DOMAINS[1]} \
    ${@}
}

function _get_latest_version_from_github()
{
  local path=${@}
  if ! [[ ${path} =~ [a-z]\/[a-z] ]]; then
    echo "Invalid path provided to ${FUNCNAME[0]}. Must be like \"this/that\""
    return 1
  fi
  local version=$(curl -s -H "Authorization: Bearer ${GITHUB_API_TOKEN}" \
    https://api.github.com/repos/${path}/releases/latest | jq -r '.tag_name')
  if [[ ${version} =~ ^v[0-9].* ]] || [[ ${version} =~ ^[0-9].* ]]; then
    echo ${version/v}
  else
    echo "Invalid version returned for \"${FUNCNAME[0]} ${path}\""
    return 1
  fi
}
function get_kube_versions()
{
  local L8ST_COREOS_V=$(curl -s https://coreos.com/dist/aws/aws-stable.json \
    | jq -r '.release_info.version') \
  local CURR_KOPS_V=$(kops version | awk '{print $2}') \
  local L8ST_KOPS_V=$(_get_latest_version_from_github "kubernetes/kops")
  local CURR_K8S_V=$(kubectl version --short --output=json | jq -r '.serverVersion.gitVersion')
  local L8ST_K8S_V=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)
  local CURR_HELMC_V=$(helm version --client --short | awk '{print $2}')
  local CURR_HELMS_V=$(helm version --server --short | awk '{print $2}')
  local L8ST_HELM_V=$(_get_latest_version_from_github "helm/helm")
  # TODO: GO_V=$(kubectl version --short --output=json | jq -r '.serverVersion.goVersion')
  # TODO: Versions of kernel, Debian/coreos/container-optimized-os-from-google, docker, etcd, kube-aws,
  #  kiam-server, kernel, nginx ingress, dashboard, heapster->metrics-server, kube-state-metrics, prometheus
  # TODO: providers for dns and network layer
  # datadog agent+chart, sumologic-fluentd agent+chart, runatlantis/atlantis

  # TODO: utilize column command?
  cat << TABLE_EOF
  +------------+------------------+----------------+
  | COMPONENT  | CURRENT VERSION  | LATEST VERSION |
  +------------+------------------+----------------+
  | CoreOS     | N/A              | ${L8ST_COREOS_V}       |
  +------------+------------------+----------------+
  | Kops       | ${CURR_KOPS_V}           | ${L8ST_KOPS_V}         |
  +------------+------------------+----------------+
  | Kubernetes | ${CURR_K8S_V}          | ${L8ST_K8S_V}        |
  +------------+------------------+----------------+
  | Helm Client| ${CURR_HELMC_V} | ${L8ST_HELM_V}        |
  +------------+------------------+----------------+
  | Helm Server| ${CURR_HELMS_V} | ${L8ST_HELM_V}        |
  +------------+------------------+----------------+
TABLE_EOF
}

function helm_diff()
{
  local release=${1}
  helm get values -a ${release} > before.yaml
  helm upgrade name-of-service path-to-chart/ --dry-run --debug --wait --reuse-values --timeout 600 \
    -f values.yaml \
    -f "${release}-values.yaml" \
    sed -n '/COMPUTED VALUES:/,/HOOKS:/{/COMPUTED VALUES:/b;/HOOKS:/b;p}' > after.yaml
  diff before.yaml after.yaml
  rm before.yaml after.yaml

  # or https://github.com/databus23/helm-diff
}
