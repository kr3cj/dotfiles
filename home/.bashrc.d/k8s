[[ $- = *i* ]] || return
${IS_OSX} || return

export KUBECONFIG=~/.kube/bar:~/.kube/bar:~/.kube/bar:~/.kube/test1:~/.kube/k8s:~/.kube/k8s-staging

# source <(kubectl completion bash) # slow
# alias k=kubectl
# source <(kubectl completion bash | sed 's/kubectl/k/g' )

function kubectl() {
  case ${@} in
    *get?componentstatus|*get?all)
      $(which kubectl) ${*} ;;
    *get?no*)
      $(which kubectl) --label-columns=nodegroup_name,function --sort-by=.metadata.creationTimestamp ${*} ;;
    *get?po*|*get?ds*|*get?svc*|*get?deploy*)
      $(which kubectl) --sort-by=.metadata.creationTimestamp ${*} ;;
    *)
      $(which kubectl) ${*} ;;
  esac
}
function eks() {
  # usage: "eks bar get po -n operations | grep datadog"
  local cluster=${1}
  if ! [[ -r ~/.kube/${cluster} ]]; then
    echo "No kubeconfig found for \"${cluster}\"!"
    return 1
  fi
  shift
  local action="${@}" # ex: "get pod"

  local my_aws_profile="" # dynamically determine
  case ${cluster} in
    bar|*prod*) my_aws_profile="saml-prod-sudo" ;;
    bar|c[0-9][0-9]|*stag*) my_aws_profile="k8s-stage-sudo" ;;
    test1) my_aws_profile="saml-pmts-prod" ;;
    *)  ;;
  esac
  # verify that eks clusters mapped to a my_aws_profile
  if [[ ! ${cluster} =~ k8s ]] && [[ "${my_aws_profile}" == "" ]]; then
    return 1
  fi
  if [[ ${cluster} =~ k8s ]] && \
   ! $(ping -c1 -W1 -i0.1 tools.${CUSTOM_WORK_DOMAINS[0]} &> /dev/null); then
    read -t 2 -s -p "You must connect to work VPN, press Enter..." && work_vpn
    echo
  fi

  local kube_config="--kubeconfig ${HOME}/.kube/${cluster}"
  # some kubectl plugin commands won't work with "--kubeconfig"
  if [[ ${action} =~ "outdated" ]] || [[ ${action} =~ "node-admin" ]]; then
    kube_config=""
  fi
  # [[ ${VERBOSE} -ge 1 ]] &&
  echo "Running: \"kubectl ${kube_config} ${action}\""
  kubectl ${kube_config} ${action} #--context admin@${cluster}
}

function helms() {
  # usage: "helms bar ls | grep gift-card-service"
  local cluster=${1}
  if ! [[ -r ~/.kube/${cluster} ]]; then
    echo "No kubeconfig found for \"${cluster}\"!"
    return 1
  fi
  shift
  local action=${@} # ex: "get pod"

  local my_aws_profile="" # dynamically determine
  case ${cluster} in
    bar|*prod*) my_aws_profile="saml-prod-sudo" ;;
    bar|c[0-9][0-9]|*stag*) my_aws_profile="k8s-stage-sudo" ;;
    test1) my_aws_profile="saml-pmts-prod" ;;
    *)  ;;
  esac
  # verify that eks clusters mapped to an my_aws_profile
  if [[ ! ${cluster} =~ k8s ]] && [[ "${my_aws_profile}" == "" ]]; then
    return 1
  fi
  if [[ ${cluster} =~ k8s ]] && \
   ! $(ping -c1 -W1 -i0.1 tools.${CUSTOM_WORK_DOMAINS[0]} &> /dev/null); then
    read -t 2 -s -p "You must connect to work VPN, press Enter..." && work_vpn
    echo
  fi

  local kube_config="--kubeconfig ${HOME}/.kube/${cluster}"

  # old kops clusters dont need saml2aws wrapper
  # local wrapper="saml2aws exec --exec-profile=${my_aws_profile} --"
  local helm_path="/Users/coreybar/.asdf/shims/helm"
  if [[ ${cluster} =~ "k8s-" ]]; then
    wrapper=""
    # k8s-staging is 2.11
    helm_path="$(asdf where helm 2.11.0)/bin/helm"
  fi

  #[[ ${VERBOSE} -ge 1 ]] &&
  echo "Running: \"${helm_path} ${kube_config} ${action}\""
   ${helm_path} ${kube_config} ${action} #--kube-context admin@${cluster}
}

# kubectl plugin manager: krew
export KREW_ROOT=${HOME}/.krew
pathadd ${KREW_ROOT}/bin

function _get_latest_version_from_github()
{
  # mostly replaced by kubectl/krew outdated
  local path=${@}
  if ! [[ ${path} =~ [a-z]\/[a-z] ]]; then
    echo "Invalid path provided to ${FUNCNAME[0]}. Must be like \"this/that\""
    return 1
  fi
  local version=$(curl -s -H "Authorization: Bearer ${GITHUB_API_TOKEN}" \
    https://api.github.com/repos/${path}/releases/latest | jq -r '.tag_name')
  if [[ ${version} =~ ^v[0-9].* ]] || [[ ${version} =~ ^[0-9].* ]]; then
    echo ${version/v}
  else
    echo "Invalid version returned for \"${FUNCNAME[0]} ${path}\""
    return 1
  fi
}
function get_kube_versions()
{
  # mostly replaced by kubectl/krew outdated
  local L8ST_COREOS_V=$(curl -s https://coreos.com/dist/aws/aws-stable.json \
    | jq -r '.release_info.version') \
  local CURR_KOPS_V=$(kops version | awk '{print $2}') \
  local L8ST_KOPS_V=$(_get_latest_version_from_github "kubernetes/kops")
  local CURR_K8S_V=$(kubectl version --short --output=json | jq -r '.serverVersion.gitVersion')
  local L8ST_K8S_V=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)
  local CURR_HELMC_V=$(helm version --client --short | awk '{print $2}')
  local CURR_HELMS_V=$(helm version --server --short | awk '{print $2}')
  local L8ST_HELM_V=$(_get_latest_version_from_github "helm/helm")
  # TODO: GO_V=$(kubectl version --short --output=json | jq -r '.serverVersion.goVersion')
  # TODO: Versions of kernel, Debian/coreos/container-optimized-os-from-google, etcd, kube-aws,
  #  kiam-server, kernel, nginx ingress, dashboard, heapster->metrics-server, kube-state-metrics, prometheus, eksctl?
  # TODO: providers for dns and network layer
  # datadog agent+chart, sumologic-fluentd agent+chart, runatlantis/atlantis
  # update di-4325

  ### Tools that come with the cluster (indirect versioning correlation)
  # docker: https://github.com/docker/docker-ce/releases/latest
  # cluster-autoscaler latest version matches k8s: https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler#releases
  # kube-state-metrics: https://github.com/kubernetes/kube-state-metrics#compatibility-matrix

  # TODO: utilize column command?
  cat << TABLE_EOF
  +------------+------------------+----------------+
  | COMPONENT  | CURRENT VERSION  | LATEST VERSION |
  +------------+------------------+----------------+
  | CoreOS     | N/A              | ${L8ST_COREOS_V}       |
  +------------+------------------+----------------+
  | Kops       | ${CURR_KOPS_V}           | ${L8ST_KOPS_V}         |
  +------------+------------------+----------------+
  | Kubernetes | ${CURR_K8S_V}          | ${L8ST_K8S_V}        |
  +------------+------------------+----------------+
  | Helm Client| ${CURR_HELMC_V} | ${L8ST_HELM_V}        |
  +------------+------------------+----------------+
  | Helm Server| ${CURR_HELMS_V} | ${L8ST_HELM_V}        |
  +------------+------------------+----------------+
TABLE_EOF
}

# function doit () {
#   local saml2aws-profile=${1}
#   shift
#   local nodes=${@}
#   for node1 in ${nodes} ; do
#     echo -e "\n starting on ${node1} at $(date)"
#     kubectl drain ${node1} --ignore-daemonsets --force --delete-local-data
#     saml2aws exec --exec-profile=${saml2aws-profile} -- \
#       aws ec2 terminate-instances --instance-ids \
#         kubectl get nodes -o go-template --template=\'{{.spec.externalID}}\' ${nodeid}
#   done
# }

# kubectl get node \
  # -l kubernetes.io/role=node,failure-domain.beta.kubernetes.io/zone=us-east-${az} \
  # --label-columns function
  # --no-headers \
  # --sort-by metadata.creationTimestamp

  # -o name

# I can get a list of pods sorted by the node its on using the below.
# But how can I show *node* labels by pod?
# kubectl get pods -o wide --sort-by="{.spec.nodeName}"

# get list of running pods on the node
# kubectl get po --field-selector=spec.nodeName=<ec2_hostname> | grep -v event-observer
