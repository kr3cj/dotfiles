alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias ducks="sudo du -cshx ./ | sort -h"
alias cdd="homeshick cd dotfiles"
alias cb="cd ~/build/github"
alias pp="source ~/.bash_profile"

function pathadd() {
  unset newpath
  local newpath=${1%/}
  if [[ ! -d "${newpath}" ]] ; then
    # echo "Directory \"${1}\" does not exist."
    return
  fi
  if [[ "${PATH}" =~ (^|:)"${newpath}"(:|$) ]] ; then
    # echo "Path \"${newpath}\" already exists in path \"${PATH}\"."
    return
  fi
  if [[ "${2}" == "after" ]] ; then
    export PATH="${PATH}:${newpath}"
  else
    export PATH="${newpath}:${PATH}"
  fi
}

function _create_socks_proxy {
  local host1=${1}
  local port1=${2}
  local test_url=${3:-"http://www.google.com"}
  local ssh_proxy_options="-f -N -D"
  local ssh_proxy_response_file="/var/tmp/ssh_proxy_response.txt"
  # clear contents of response file
  > ${ssh_proxy_response_file}
  local response

  # note: lsof still returns a row when port open but dead: lsof -nP -i4TCP:${port1} | grep -q LISTEN
  # --socks5-hostname
  response=$(curl \
    --connect-timeout 1 \
    --silent \
    --output /dev/null \
    --write-out "%{http_code}" \
    --head \
    --socks5 localhost:${port1} \
    ${test_url})
  if [[ ${response} -ne 200 ]] ; then
    # first kill any old sessions
    pgrep -f "ssh ${ssh_proxy_options} ${port1} ${host1}"
    pkill -f "ssh ${ssh_proxy_options} ${port1} ${host1}"

    echo "Establishing ssh tunnel with ${host1}:${port1}..."
    if [[ ${host1} == "home.${CUSTOM_HOME_DOMAIN}" ]]; then
      lpass show --password --clip "proxy.${CUSTOM_NAS_HOST#*\.}"
    fi
    # ssh options moved to ~/.ssh/config
    #  -o TCPKeepAlive=yes -o ConnectTimeout=1 -o ConnectionAttempts=1 \
    #  -o ServerAliveInterval=120 -o ServerAliveCountMax=2 \
    /usr/bin/ssh ${ssh_proxy_options} ${port1} "${host1}" 2> ${ssh_proxy_response_file}
  fi
  if [[ -s ${ssh_proxy_response_file} ]]; then
    echo "Unable to establish ssh connection to ${host1}."
    echo "  curl response: \"${response}\""
    echo -e "  ssh proxy response:\n$(cat ${ssh_proxy_response_file})"
    return 1
  fi
}

function port {
  # strip http.* from parameter
  local host1=${1#*//}
  # find port from either "server1:1234" or "server1 1234"
  local port1
  if [[ -n ${2} ]] && [[ ${host1} =~ ":" ]]; then
    (>&2 echo "  detected multiple port inputs; using ${2}")
    port1=${2}
    # strip port from host variable
    host1=${host1%:*}
  elif [[ -n ${2} ]]; then
    port1=${2}
  elif [[ -z ${2} ]] && [[ ${host1} =~ ":" ]]; then
    port1=${host1#*:}
    # strip port from host variable
    host1=${host1%:*}
  elif [[ -z ${2} ]] && [[ ! ${host} =~ ":" ]]; then
    (>&2 echo "You must supply a port number as an additional parameter or append \":1234\".")
    return 1
  fi

  if ! [[ "${port1}" =~ ^[0-9]+$ ]]; then
    (>&2 echo "You supplied an incorrect port.")
    return 1
  fi

  # echo "Checking host \"${host1}\" over port \"${port1}\"."
  ${timeout_path} 2 bash -c "echo >/dev/tcp/${host1}/${port1}" > /dev/null 2>&1 && echo success \
    || (>&2 echo "failure"; return 1)
}

function acp {
  cp -av ${1} ${1}.$(date --rfc-3339=date)
}

function find-error() {
  sudo grep -riE 'DENIED|ERR|EXIST|FAIL|INVALID|SPECIFIED|SUCH|UNABLE|WARN|USAGE:|UNKNOWN' ${1}
}

# https://github.com/chubin/awesome-console-services
function speedtest {
  curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py \
  | python -
}

function whatismyip {
  curl ifconfig.me
}

function weather {
  curl https://wttr.in
}

if [[ "${IS_OSX}" == "true" ]]; then
  alias curl="/usr/local/opt/curl/bin/curl"
  # since the path file hasn't been sourced yet, use absolute paths to ls for macos
  alias ls="/usr/local/opt/coreutils/libexec/gnubin/ls -G --color=auto"
  alias ll="/usr/local/opt/coreutils/libexec/gnubin/ls -hl -G --color=auto"
  alias srm="/bin/rm -vP"
  alias slack="open -a Slack"
  alias spotify="open -a Spotify"
  # alias pia="nohup ~/.pia_manager/pia_manager.app/Contents/MacOS/runner.sh >/dev/null 2>&1 &"
  # alias gphoto="open --background -a \"Google Photos Backup\""
  alias gphoto="open --background -a \"Backup and Sync\""

  function vc {
    lpass show --password --clip AD
    /opt/cisco/anyconnect/bin/vpn connect ${CUSTOM_WORK_DOMAINS[1]/\.*/}
    source ~/.bash_profile # to clean up work/home network connection configs
  }

  function clear_clip {
    # clear clipboard after N seconds
    local wait_time="${1:-0}"
    (
      {
        sleep ${wait_time}
        pbcopy < /dev/null
      } & disown
    ) 2> /dev/null
  }

  function lpass {
    ${IS_OSX} || return
    $(which lpass) "${@}"
    clear_clip 5
  }

  eval "function ssh {
    local host1=\"\${@}\"
    case \"\${host1}\" in
      ${CUSTOM_WORK_SUBNET}.*|\
$(echo ${CUSTOM_WORK_DOMAINS[@]/#/*.}|tr ' ' '|'))
        lpass show --password --clip \"${CUSTOM_WORK_DOMAINS[0]/.com/} main (one login)\";;
      home.${CUSTOM_HOME_DOMAIN})
        lpass show --password --clip \"proxy.${CUSTOM_NAS_HOST#*\.}\" ;;
      nas|nas.${CUSTOM_NAS_HOST#*\.})
        lpass show --password --clip \"nas.${CUSTOM_NAS_HOST#*\.}\" ;;
      web|web.${CUSTOM_NAS_HOST#*\.})
        lpass show --password --clip \"web.${CUSTOM_NAS_HOST#*\.}\" ;;
      ship|ship.${CUSTOM_NAS_HOST#*\.})
        lpass show --password --clip \"ship.${CUSTOM_NAS_HOST#*\.}\" ;;
      plex|plex.${CUSTOM_NAS_HOST#*\.})
        lpass show --password --clip \"plex.${CUSTOM_NAS_HOST#*\.}\" ;;
      proxy|proxy.${CUSTOM_NAS_HOST#*\.})
        lpass show --password --clip \"proxy.${CUSTOM_NAS_HOST#*\.}\" ;;
      macbuild*)
        lpass show --password --clip AD ;;
    esac
    # using homebrew ssh $(which ssh) results in 'Bad configuration option: usekeychain'
    /usr/bin/ssh \${host1}
  }"

  function openit {
    # quickly opens macos programs in the background if not already running
    local -a programs=("${@}")
    local program1
    local -i item

    for ((item = 0; item < ${#programs[@]}; item++)); do
      program1="${programs[${item}]}"
      pgrep -qf "${program1}.app" || (nohup open --hide --background -a "${program1}" >/dev/null 2>&1 &)
    done
  }
elif [[ "${IS_LINUX}" == "true" ]]; then
  alias ls="ls --color=auto"
  alias ll="ls -hal --color=auto"
  alias list-services="systemctl list-unit-files --type=service | grep enabled | \
    cut -d. -f1 | sort"
  # enforce one use of clipboard memory
  export LPASS_CLIPBOARD_COMMAND="xclip -selection clipboard -in -l 1"

  function aria() {
    $(which aria2c) \
    --continue=true \
    --always-resume=true \
    --seed-ratio=1.0 \
    --check-integrity=true \
    --dir=/share/ \
    ${1}
  }
  # -x2 \
fi
